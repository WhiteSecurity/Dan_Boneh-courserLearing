2018.1.12

1.What is block cipher?How use the block cipher correctly?
   DES and AES main idea : key k expansion to k1 and use the k1 encrypt the  message,get m1 called a round.
     
                                  key k expansion to k2 and use the k2 encrypt the message,get m2 called second round.
              next and next so on.......  get the cipher C.
              
2.Pseudo Random function（PRF）define over(k,x,y)keyspace,inputspace and outputspace.  F: K x X->Y
  such that exists "efficient " algorithm to evaluate F(k,x) 

  Pseudo Random Permutation (PRP) defined over(k,x) keyspace and a set X   K x X->X  伪随机置换 input one X and output another X
     the function k is one to one and exist a efficient inversion algorithm D(k,y)
    
 Example PRPs: 3DES ,AES...
   
   Functionally any PRP is also a PRF   if a PRP is a PRF where X=Y and is efficiently invertible.
  
 Secure PRFs
   Let f:k X x ->Y be a PRF 
       Fun[x,y] :the set of all functions from X to Y   Size ：Y绝对值 的X 绝对值 次方 （可以替换成各种 比如一对一的伪随机置换映射）
       Sf={F(k,*) s*t, k属于 K} 属于 Funs[X,Y] 所有的使用key k的从X到Y的Fun   Size：密钥的空间K
       
 如果我们说一个PRF是安全的，主要是因为一个随机的funs[x,y] 是不可区分的 a pseudo-ranom function in Sf
 
 more preciously （我们所要建立的伪随机产生器所要满足的安全条件）
   a adversary who trying to indistinguish truly rendom function from a preudo-randonm function .First choose a truly random function 
   from the Fun[x,y]  and choose a random key for a pseudo-random function .A adversary submit points in X,a bunch of Xs like x1,x2,,,
   我们会返回给他随机的可能用真正随机公式加密选择的k的或者伪随机公式公式选择的k加密，如果这个poor adversary 不能够区分，那么这个这个PRFs是一个安全的
   
   
   
   不能够提供帮助就闭嘴 shut up
   
   An easy application：
     PRF=> PRG
       let F 成为一个安全地伪随机公式 产生一个K
       the G 成为一个 n个比特的t个块的 key  G（K）=F（k,0）||F(k,1)||F（k,2）||F（k,3）||...F（k,t） 平行独立结构 size:nt
                                            is indistinguish from the turely random gererator 
                                                G（K）=F（0）||F(1)||F（2）||F（3）||...F（t） 互不相护影响
                                                
                                                
    ------------------------------------------------------------------------------------------------------------------------------------------
    
    2018年9月25号
    
   对于DES的穷举攻击--exhaustive attack 
    goal:give a few input and output pairs(mi,ci=(k,mi)),k=1,2,3,find key k;
    
    Lemma：Suppose DES is a idea cipher.
             对于所有的m和c，至多有一个k的概率是c=DES(k,m)
    Proof:   with the possibility is 1/256
    pr[存在k不等于k'，c=des(k,m)=(k',m)]<=对于2^56的和 pr[des(k,m)=(k',m)]<2^56*1/2^64=1/256
    
    对于两个不同的（m1,c1）,(m2,c2)来说的话，唯一的概率是1-1/2^71
    
    对于两个不同的输入输出对来说，AES-128 唯一k的概率是1-1/2^128
    
    two pair input/output is enough for exhaustive attack
    
  DES从一开始三个月长的破解期到22hour的破解期，目前发展的三重DES成为NIST的标准
     C=e(d(e(m,k1),k2),k3) , 为什么不使用 eee，在k1=k2=k3的时候可以使得3trible DES变成 DES
     
     why not use double-DES
     
        
 middle attack 
      m  ----  (k1,) --x---   (k2,) ---- c 
                                                
        1.首先做个映射表，k1的所有的可能是2^56,反向从c开始有另外一个k2的所有的可能是2^56
        2.还有一个排序的时间是time=log_2(2^56)+log_2(2^56)=2^63<<2^112次方 ，且小于2^90
       
       
       
       
        m  ----  (k1,) --x---   (k2,) ------(k3,)---- c 
       
      time log_2(2^56) + 2^63=2^118
       
       
---------------------------------------------------------------------------------------------------

2018年9月26号

AES

2000年，NIST采用Rijnael 作为AES的标准

密钥的大小：128，192，256 bits.   Block size:128 bits 密钥长度越短加密效率越高

   代换排列  substitution-permutation 并不是festial 结构，所以每次在与k异或的时候就要使的所有的bit位发生改变，而
   festital network的话是有一半的bit不会发生改变

               经过代换layer          经过代换layer
input 异或 k1 -------------> 异或 k2  -------------> 。。。。。。。。。异或kn --->output
所有的k1，k2.....k3组成一个k的集合

首先input包含一个4x4的矩阵 ，经过 substitution layer有三层1.bytesub 2.shiftrow 3.mixcloumn.

---------------------------------------------------------------------------------------------
怎么定义一个安全的PRF 和 一个安全的 PRP（secure block cipher）伪随机排列

任何一个安全的PRP便是一个安全的PRF

----------------------------------------------------------------------------------------------

goal: build secure encryption using PRPs ;

the segment :one-time key
 adversary power:
     adversary sees only one ciphertext;(one-time key)

adversary goal:
    Learn info about PT from CT(semantic security)
    
    
    incorrect using PRPs
Electrioc code Book :
  如果使用两个相同的块进行加密，得到密文是相等的
  如果攻击者看到两个块是相等的，那么攻击者就会猜到两个明文是一样的
EBC 并不是语意安全的，如果给两个相同的pt来进行加密，当包含多个块的时候

用两个不相同的m1和m2，m1是两个不相同的块，m2是两个相同的块，如果攻击者把m1和m2给挑战者，出现两个不同的c1和c2，攻击者能够从中区分，所以
EBC并不是语意安全的。
  improve:使用决定计数模式来进行流加密，攻击者来攻击成功简单计数模式的的概率是攻击成功PRF的概率的两倍，因为攻击成功PRF的概率是可忽略的，所以
  使用决定计数模式也是安全的。
   
   
   
----------------------------------------------------------------------------------------
在块加密中使用同一个密钥加密多条信息

   













   
   
   
   
   
   
         
       
       
       
       
       
       
       
       
              
       
             
      
    
