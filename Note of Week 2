2018.1.12

1.What is block cipher?How use the block cipher correctly?
   DES and AES main idea : key k expansion to k1 and use the k1 encrypt the  message,get m1 called a round.
     
                                  key k expansion to k2 and use the k2 encrypt the message,get m2 called second round.
              next and next so on.......  get the cipher C.
              
2.Pseudo Random function（PRF）define over(k,x,y)keyspace,inputspace and outputspace.  F: K x X->Y
  such that exists "efficient " algorithm to evaluate F(k,x) 

  Pseudo Random Permutation (PRP) defined over(k,x) keyspace and a set X   K x X->X  伪随机置换 input one X and output another X
     the function k is one to one and exist a efficient inversion algorithm D(k,y)
    
 Example PRPs: 3DES ,AES...
   
   Functionally any PRP is also a PRF   if a PRP is a PRF where X=Y and is efficiently invertible.
  
 Secure PRFs
   Let f:k X x ->Y be a PRF 
       Fun[x,y] :the set of all functions from X to Y   Size ：Y绝对值 的X 绝对值 次方 （可以替换成各种 比如一对一的伪随机置换映射）
       Sf={F(k,*) s*t, k属于 K} 属于 Funs[X,Y] 所有的使用key k的从X到Y的Fun   Size：密钥的空间K
       
 如果我们说一个PRF是安全的，主要是因为一个随机的funs[x,y] 是不可区分的 a pseudo-ranom function in Sf
 
 more preciously （我们所要建立的伪随机产生器所要满足的安全条件）
   a adversary who trying to indistinguish truly rendom function from a preudo-randonm function .First choose a truly random function 
   from the Fun[x,y]  and choose a random key for a pseudo-random function .A adversary submit points in X,a bunch of Xs like x1,x2,,,
   我们会返回给他随机的可能用真正随机公式加密选择的k的或者伪随机公式公式选择的k加密，如果这个poor adversary 不能够区分，那么这个这个PRFs是一个安全的
   
   
   
   不能够提供帮助就闭嘴 shut up
   
   An easy application：
     PRF=> PRG
       let F 成为一个安全地伪随机公式 产生一个K
       the G 成为一个 n个比特的t个块的 key  G（K）=F（k,0）||F(k,1)||F（k,2）||F（k,3）||...F（k,t） 平行独立结构 size:nt
                                            is indistinguish from the turely random gererator 
                                                G（K）=F（0）||F(1)||F（2）||F（3）||...F（t） 互不相护影响
                                                
                                                
    ------------------------------------------------------------------------------------------------------------------------------------------
    
    2018年9月25号
    
   对于DES的穷举攻击--exhaustive attack 
    goal:give a few input and output pairs(mi,ci=(k,mi)),k=1,2,3,find key k;
    
    Lemma：Suppose DES is a idea cipher.
             对于所有的m和c，至多有一个k的概率是c=DES(k,m)
    Proof:   with the possibility is 1/256
    pr[存在k不等于k'，c=des(k,m)=(k',m)]<=对于2^56的和 pr[des(k,m)=(k',m)]<2^56*1/2^64=1/256
    
    对于两个不同的（m1,c1）,(m2,c2)来说的话，唯一的概率是1-1/2^71
    
    对于两个不同的输入输出对来说，AES-128 唯一k的概率是1-1/2^128
    
    two pair input/output is enough for exhaustive attack
    
  DES从一开始三个月长的破解期到22hour的破解期，目前发展的三重DES成为NIST的标准
     C=e(d(e(m,k1),k2),k3) , 为什么不使用 eee，在k1=k2=k3的时候可以使得3trible DES变成 DES
     
     why not use double-DES
     
        
 middle attack 
      m  ----  (k1,) --x---   (k2,) ---- c 
                                                
        1.首先做个映射表，k1的所有的可能是2^56,反向从c开始有另外一个k2的所有的可能是2^56
        2.还有一个排序的时间是time=log_2(2^56)+log_2(2^56)=2^63<<2^112次方 ，且小于2^90
       
       
       
       
        m  ----  (k1,) --x---   (k2,) ------(k3,)---- c 
       
      time log_2(2^56) + 2^63=2^118
       
       
       
   
   
   
   
   
   
   
   
   
   
         
       
       
       
       
       
       
       
       
              
       
             
      
    
