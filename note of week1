learning overview
        1.the inner workings of cryptography promitives and how to correctly use them
        2.how to reason about the security of cryptographic constructions  
        3.how to apply this knowledge to real-world applications

organization       
       1.a detailed discussion of how two parties who have a shared secret key whene facing powerful adversary and tampers with traffic 
       2.public-key techniques that let two parties generate a shared sercet key
       
homework and grading 
        1.weekly problem and solve it within 8 hours 
        2.the language of  programming assignments is no-limitation 
        3.grade more than 80% is passing 
        4.final exam(no midterm)
        
free resourse to supplement the lecture 
      1.A course in applied cryptography and computational number theory
      2. https://en.wikibooks.org/wiki/High_School_Mathematics_Extensions/Discrete_Probability
      
      
--------------------------------------------------------------------------------------------------------------------------------
12.15 lity and integrity
 
 
1.2 wireless traffic: wpa2,GSM ,Bluetooth   
   
2. encrypting  files on disk   prevent the data form modifying and eavedropong  
    
3.content protection :  DVD css ; Blu-ray,AAcs
 
4. user authentication

single use key  email
multi use key 

cryptography is a tremendous tool and the bais for many security mechanisms 
disadvatage:
cryptography is not the solition to all security for example 1. software bug 2. society engineering attack
             reliable unless implemented and used properly 
             
                    
---------------------------------------------------------------------------------------------------------------------------------------   
  
  What is the cryptography
    
    crypto core 
          1.sectet key establishment 
          2.secure communication  confidentiality and integrity
          
   for example applications
   1.digital signatures 
           how to make sure the source of the document 
     
   2.anonymous communication(mix net ) 
            want to talk  the doctor about the medical condition but don't want the doctor konw her name
            
   3.Anonymous digital cash
        the problem is that Alice spent the cash only once ,nobody will know the Alice's identity,but Alice spend twice ,all of the 
        a sudden her identity is completely exposed and then she could be subject to all sorts of legal problems 
        
   4.election  System  can compute the majority fo the votes but do it in such that nothing else is revealed about their individual votes 
   
   5.private autions  compute the winner of the highest bidder
   
   6.multi-party computation   6.1trusted authority 
   
   
                               6.2without the authority talk to each other and get a value of the function
   
   
   7.private outsourcing computation   Alice search query to google ,but google don't know who and what the query is 
   
   8. zero konwledge
   
   A rigorous science                             signature 
   1.precisely specify threat model               unfogy
   2.propose a construcion                          
   3.prove that breaking construction under threat mode  will solve an underlying hard problem
   
   
   -------------------------------------------------------------------------------------------------------------------------------------
   
   
   
   The History of the cryptography
           symmetric ciphers
                             <The code breaker>
                             
   1. substitutuion cipher    
      caesar cipher  shift by 3   a--->d  b--->e................
         break: a: the key space is 26 factorial  but using the letter frequency is eaay to break it.
                     e is about 12.7%    
                     
                 b:use  frequency of pairs of letters
                     th    he 
                     
      vigene cipher  use the word as the key   add the key letters to the message letters ,modulo 26               
                  a: assume the length of the key1.....n
      
      
      Rotor Machines  
                      most famous :the Enigma (3-5 rotors) 
                      
       Data encryption Standard    
            DeS
            
            Today AES   Salsa20
   
   -----------------------------------------------------------------------------------------------------------------------------------
   
   12.17
    Discrete  probablity  离散概率 -----》(概率论) 
      def : probability distribution P over U is a function P:U---->[0,1]
        
        1.Uniform distribution for all x属于U:p(x)=1/|u|
        2.point distribution at X0: p(x0)=1,对于所有不等于x0的x，p(x)=0
        
     events 
         发生某项事件的概率 For a set A属于U，P[A]是事件x的概率 这个A称为事件
         
     The union bound
         两个事件发生的概率小于等于两个时间发生概率之和
         
      Random variables  随机变量
         Def: a random Variable X is a function  X:U--->V
           
         
     The uniform random variable 
         随机事件发生的概率 ，
           1.deterministic algorithm:y<-----A(M)
           2.randomized algorithm ： y<------A(m;r) where r<-----{0,1}的n次幂
            r是一个隐式变量，每次进行一个随机算法会产生不同的output
             
   
    independence:    p[AB]=P[A]P[B] 两个事件相互独立 
    
         -------》XOR 
                  def：相同为0，不同为1 ，XOR has an important property 
                  
                  取两个相互独立的｛0，1｝的，一个是通过随机算法的得出·的，一个是符合均匀分布，结果相互异或， 将会得到一个均匀的随机变量
   
  proof 对于n=1 的时候 ｛0，1｝产生0的概率是p1,产生1的概率是p2，所以产生｛00｝和｛11｝的概率是
   
   
生日   悖论  the birthday paradox
     Let r1,r2,...rn属于集合U，它们是相互独立的
         Thm： when n=1.2*|U|根号次方 ，两个相同的概率大于等于1/2,
         U全体的空间
         
         
            -----------------------------------------------------------------------------------------------------------------------------
    12.18   ,12.21 号补充
    
    def Symmetric Ciphers ：D(k,E(k,m))=m   对于所有m属于M，k属于Gx 来说
    E is often output  randomized results  and D is always  output deterministic  result 
    
     why  the one-time-pad is  security?
     
        def the security: 1. basic idea: CT should revel no "info" ablout PT
                         Let's formulize,formally expalin what does information about the plain text actually mean
                  
                    Def
                       对于所有的密文m0，m1属于密文空间M，and length of m0 and m1 is same,对于每个密文属于密文空间
                       Pr[E(k,m0)=c]=Pr[E(k,m1)=c] k是从密钥空间K中随机选的
                        我不能知道message是m0和m1对于所有的m0和m1
                     proof: 
                    对于所有的密文和密钥，通过密钥k来加密密文得到C的可能性是等于  从密钥空间中选出从可以把明文m加密成c的所有个数/密钥空间的大小
                    
                    如果从密钥空间中选出从可以把明文m加密成c的所有的个数是一个常数,那么称这个加密具有完美的保密性
              
              lemma： 对于OTP来说，从E(k,m)=c,c=m异或k，而k=m异或c，k具有唯一性，所以OTP是具有完美的保密性的
              
              证明了对于密文攻击，OTP是十分有效的
                    
     
     
     One_Time_pad  一次一密    sth be careful when use the stream cipher密码流 使用明文和密钥进行一个字接一个字节的加密
    
    1.it is diffcult to use in practice( as long as the message and diffcult to generate the real random bit)
    2.THm ，the number of the key must more or equal to the number of the bite of message
       
     
   
     ------------------------------------------------------------------------------------------------------------------------------
   12.22
   make one time pad partical by using a pseudo random generator  伪随机生成器 need unpredictable but hard to accomplish
       pRG must be un-predictable
          if one byte can be predicted ,the eavedropper may get the next the byte.At last,he will get all message.
      算法A中我给出前缀的几个字节的输入，能够预测出接下来几个的输出， 的概率大于等于二分之一加上一个不可忽略的ε 
      
     Weak  PRGS 
       r[0]=seed 
        r[i]<----a*r[i-1]+b  mod p
          output few bits of r[i]
          
     
     
     对于ε的def：
         in practice :    ε>=1/2 30次方 称为不可忽略的， ε<=1/2 的80 次方称为可忽略的
         in theroy  ：    ε大于一个多项式时间称为不可忽略的，ε小于所有多项式时间称为可忽略的
          
  ----------------------------------------------------------------------------------------------------------------------------------    
       
       
    E(k,m)=m异或G（k） ，D(k,c)=c异或G(k)
    
   1. if i use two time pad  is inscurity  should never use twice
         c1=m1 xor PRG(k)
         C2=m2 xor PRG(k)
         C1 xor C2=m1 xor m2  because english has lots of redundancy finally get m1,m2
        
  Real world examples 
       1.Project Venona 
     generate a one time by throwing dice  
      2.Windoms NT MS-PPTP 
          point-to-point transfer protocol 
  different key fot  c--->s and s----->c
                       
                    --------------                            -------------------   
       client                          k(k s-->c,k c--->s)                              sever 
       k(k s-->c,k c--->s)                                                         k(k s-->c,k c--->s)
                    --------------                              ------------------        
  the really key is a pair of key ,one key is used to encrypt messages from server to client,
                                         and one is uesd to encrypt messges form client to server
                                         
  3.WIFI-communication 802.11b 
       
    contains an encryption layer and the original encryption layer was called WEB 
               
                                           frame 
               -------------------                          -----------------------
  client secret key k                plain text M and CRC（M）                        sercret key k access point 
                                          PRG(IV || key)
                   the stream cipher is this concatenation of a calue IV and a long term key K 
                   （change the stream cipher key by using the different IV to prepend the K）
            IV is a 24 bit string when transfer a message to the access point it will change the IV every time
      所以问题1：是IV只具有24bit的长度，所以它的所有的可能性是2的24次方，最坏情况下在2的24次方之后肯定会出现重复的现象，所以不安全
                  会出现 Two ——time——pad 
          问题2:the basically idea   wanted to use  a different key for every packet 
               -------------------                          ------------------------
   
   
   12.29 补充WEP协议的劣势
        问题二：PRG的算法是RC4，但是在Fluhrer,Mantin and Shamir发现，在10的六次方的使用的情况下，能重现secret key 
        （because of the secret keys is so closely related） 
        
      improvement
       1.使用三个合成的message 来扩大长度，避免相关的secret key，从而导致从密码的相关性来推出明文
       ------》与其不断改变IV，不如改变PRG的值，使用多个明文和多个PRG key 来拓展密码的长度和避免相关性
       
       
    4.another example ： disk encryption
       the message is encrypted by block to block ，so the attack can analyse the change between the  different message.
       so it's not secutity to use the two-time-pad in the disk encryption 
        
        summary
          1.Network traffic :nogotiate new key for every session
          2.Disk encruption: typocally do not use a stream cipher
  
  no integrity   
      [  (m xor k) xor P ] xor k = x xor p 
       so the attacker can change the message ,so it is no integrity. 
       
       比如在现实生活中，攻击者想要使信息的所有者从BOB 变成 eve 可以直接使用异或使得信息的所有者发生变化
    
    
    stream cipher use in practice
    1.RC 4（1987）通过循环迭代产生每次产生一个的byte，it fairly use in the procotol like Https and WeP
     Two weakness :
        1.RC 4 如果是完全的随机的话，在第二个字节出现是0的概率不是1/256,而是2/256（出现偏差） ，如果你用RC 4 来加密数据，第二个字节可能完全没有被加密，它会被
        0异或两倍的可能性，相较于它本应该的概率。在使用RC 4的时候应该使用Byte257 
        2.出现00的概率是 1/256的2次方 +1/256的三次方 
        3.related key attacks
        
   
   
   
   2.badly brokes stream cipher used for encryption DVD movies CSS（content scrambling system ）
    hardware basiclly rely on the linear feedback shift register (线性反馈移位寄存器) lfsr
    
    seed = initial state of the LFSR 
    the Lfsr use the certain cell which contains a bit doing xor operation,the result will become the first cell and the
  last cell will fall off.
    
  
  DVD encryption use the two LFSRs
  GSm use the A51/A52. three LFSRs 
  Bluetooth E0:four LFSRs
       
     css  contains 5 bytes =40 bits
     
                               the first LFSR  1 || first 2 Bytes  17 bits   ---8 cycle times outputs 8 bits
     there are have two LFSR                                                                            +module 256=(0 -- 256)1 bytes per round
                              the second LFSR  1 || last 3 Bytes. 25 bits   ---8 cycle times putputs 8 bits
     
     
  Easy to attack (premise : DVD encryption use the MPEG　files, you will know  a prefix of the plaintext contains 20 bytes)
      First ,  using  the encryption text XOR the known the plaintext 20 bytes ,then get the first twenty bytes of the output of CSS
      Second,  assuming an the inital form the first LFSR in the 2的17次方‘s possibility , run the initial number and get the 20 bytes.
      Third,   then using the CSS substract the getted 20 bytes ,judging whether the result is correct.
      So you can get the second LFSR initial  sequence. At last ,you will get all LFSR sequence and predict the all remaining outputs
      of CSS.
      
  Modern stream cipher
     
      eStream 
       seed{0,1} s上标 and a nonce R -->{0,1} n上标. 其中n远大于s
         nonce represent a unrepeatable  value for given key
         
         Salsa 20
         s=128/256 bits     (n= 2 73 bits)max  a nonce contains 64 bits
         
         Salsa20(k;r)=H(k,(r,0))||H(k,(r,1))||.....
           given the key and the nonce getting the  a long pseudorandom sequence by dong the function H .Function H contains three inputs
        the k the nonce and counter incressed one by one.
         
         how the H() works:
           use a invertible function h get the point to point map and cycle 10 times ,useing the result add the previous data ,finally 
        getting the presuse result.that's all 
        
        In pratice :
           the PC4 runs  slowest and the salsa 20 run 643Mb/sec and the sosemanuk 727 MB/sec
           
                   
         
         
         
         
     
       
         
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
   
   
   
   
   
       
       
      
      
